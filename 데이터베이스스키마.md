# 데이터베이스 스키마
## 원가관리 시스템 DB 설계

### 1. 개요
- **DBMS**: SQLite (개발) / PostgreSQL (운영)
- **ORM**: Prisma ORM
- **문자 인코딩**: UTF-8
- **데이터 무결성**: 외래키 제약조건 적용

### 2. 테이블 구조

#### 2.1 Materials (재료) 테이블
```sql
CREATE TABLE materials (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL UNIQUE,
  cost DECIMAL(10,0) NOT NULL CHECK (cost >= 0),
  description TEXT,
  supplier VARCHAR(255),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 인덱스
CREATE INDEX idx_materials_name ON materials(name);
CREATE INDEX idx_materials_cost ON materials(cost);
```

**필드 설명**
- `id`: 재료 고유 ID (Primary Key)
- `name`: 재료명 (고유값, 검색에 사용)
- `cost`: 재료 원가 (원 단위, 음수 불가)
- `description`: 재료 상세 설명 (선택사항)
- `supplier`: 공급업체명 (선택사항)
- `created_at`: 생성일시
- `updated_at`: 수정일시

#### 2.2 Categories (카테고리) 테이블
```sql
CREATE TABLE categories (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL UNIQUE,
  description TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 기본 카테고리 데이터
INSERT INTO categories (name) VALUES 
  ('필러'), ('보톡스'), ('레이저'), ('스킨케어'), ('기타');
```

**필드 설명**
- `id`: 카테고리 고유 ID
- `name`: 카테고리명 (필러, 보톡스 등)
- `description`: 카테고리 설명

#### 2.3 Procedures (시술) 테이블
```sql
CREATE TABLE procedures (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  category_id INTEGER REFERENCES categories(id),
  customer_price DECIMAL(10,0) NOT NULL CHECK (customer_price >= 0),
  is_recommended BOOLEAN DEFAULT FALSE,
  notes TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 인덱스
CREATE INDEX idx_procedures_name ON procedures(name);
CREATE INDEX idx_procedures_category ON procedures(category_id);
CREATE INDEX idx_procedures_price ON procedures(customer_price);
CREATE INDEX idx_procedures_recommended ON procedures(is_recommended);
```

**필드 설명**
- `id`: 시술 고유 ID (Primary Key)
- `name`: 시술명
- `category_id`: 카테고리 외래키
- `customer_price`: 고객 가격 (원 단위)
- `is_recommended`: 추천 제품 여부
- `notes`: 시술 관련 메모
- `created_at`: 생성일시  
- `updated_at`: 수정일시

#### 2.4 Procedure_Materials (시술-재료 연결) 테이블
```sql
CREATE TABLE procedure_materials (
  id SERIAL PRIMARY KEY,
  procedure_id INTEGER NOT NULL REFERENCES procedures(id) ON DELETE CASCADE,
  material_id INTEGER NOT NULL REFERENCES materials(id) ON DELETE CASCADE,
  quantity DECIMAL(8,2) DEFAULT 1.0 CHECK (quantity > 0),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  
  UNIQUE(procedure_id, material_id)
);

-- 인덱스
CREATE INDEX idx_procedure_materials_procedure ON procedure_materials(procedure_id);
CREATE INDEX idx_procedure_materials_material ON procedure_materials(material_id);
```

**필드 설명**
- `id`: 연결 관계 고유 ID
- `procedure_id`: 시술 외래키
- `material_id`: 재료 외래키  
- `quantity`: 사용량 (기본값: 1.0)
- **복합 유니크**: (procedure_id, material_id) 중복 방지

#### 2.6 Upload_Jobs (업로드 작업) 테이블
```sql
CREATE TABLE upload_jobs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  type VARCHAR(50) NOT NULL CHECK (type IN ('materials', 'procedures')),
  file_name VARCHAR(255) NOT NULL,
  file_size INTEGER,
  original_data JSONB, -- 롤백을 위한 원본 데이터 백업
  total_rows INTEGER DEFAULT 0,
  processed_rows INTEGER DEFAULT 0,
  success_rows INTEGER DEFAULT 0,
  error_rows INTEGER DEFAULT 0,
  status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed', 'rollback')),
  progress_percentage DECIMAL(5,2) DEFAULT 0,
  error_details JSONB, -- 오류 상세 내역
  upload_options JSONB, -- 업로드 옵션 (추가/업데이트/전체교체)
  started_at TIMESTAMP,
  completed_at TIMESTAMP,
  created_by VARCHAR(255),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 인덱스
CREATE INDEX idx_upload_jobs_status ON upload_jobs(status);
CREATE INDEX idx_upload_jobs_type ON upload_jobs(type);
CREATE INDEX idx_upload_jobs_created_at ON upload_jobs(created_at);
```

**필드 설명**
- `id`: 작업 고유 ID (UUID)
- `type`: 업로드 타입 (materials/procedures)
- `file_name`: 업로드된 파일명
- `original_data`: 롤백용 원본 데이터 (JSON)
- `total_rows`: 전체 처리할 행 수
- `processed_rows`: 현재까지 처리된 행 수
- `success_rows`: 성공한 행 수
- `error_rows`: 실패한 행 수
- `status`: 작업 상태
- `error_details`: 오류 상세 정보 (JSON)
- `upload_options`: 업로드 설정 (JSON)

#### 2.8 Price_History (가격 이력) 테이블 (선택사항)
```sql
CREATE TABLE price_history (
  id SERIAL PRIMARY KEY,
  material_id INTEGER NOT NULL REFERENCES materials(id),
  old_price DECIMAL(10,0) NOT NULL,
  new_price DECIMAL(10,0) NOT NULL,
  changed_by VARCHAR(255),
  change_reason TEXT,
  changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 인덱스
CREATE INDEX idx_price_history_material ON price_history(material_id);
CREATE INDEX idx_price_history_date ON price_history(changed_at);
```

### 3. 뷰 (Views)

#### 3.1 Procedure_Summary 뷰
```sql
CREATE VIEW procedure_summary AS
SELECT 
  p.id,
  p.name,
  c.name as category_name,
  p.customer_price,
  COALESCE(SUM(m.cost * pm.quantity), 0) as total_cost,
  p.customer_price - COALESCE(SUM(m.cost * pm.quantity), 0) as margin,
  CASE 
    WHEN p.customer_price > 0 
    THEN ROUND(((p.customer_price - COALESCE(SUM(m.cost * pm.quantity), 0)) * 100.0 / p.customer_price), 1)
    ELSE 0 
  END as margin_rate,
  p.is_recommended,
  p.created_at,
  p.updated_at
FROM procedures p
LEFT JOIN categories c ON p.category_id = c.id
LEFT JOIN procedure_materials pm ON p.id = pm.procedure_id
LEFT JOIN materials m ON pm.material_id = m.id
GROUP BY p.id, p.name, c.name, p.customer_price, p.is_recommended, p.created_at, p.updated_at;
```

#### 3.2 Dashboard_Stats 뷰
```sql
CREATE VIEW dashboard_stats AS
SELECT 
  COUNT(*) as total_procedures,
  ROUND(AVG(margin_rate), 1) as avg_margin_rate,
  MAX(margin) as max_margin,
  COUNT(CASE WHEN is_recommended = TRUE THEN 1 END) as recommended_count,
  ROUND(AVG(customer_price), 0) as avg_price
FROM procedure_summary;
```

### 4. Prisma Schema (schema.prisma)

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // or "sqlite" for development
  url      = env("DATABASE_URL")
}

model Category {
  id          Int         @id @default(autoincrement())
  name        String      @unique @db.VarChar(100)
  description String?     @db.Text
  createdAt   DateTime    @default(now()) @map("created_at")
  procedures  Procedure[]

  @@map("categories")
}

model Material {
  id                  Int                  @id @default(autoincrement())
  name                String               @unique @db.VarChar(255)
  cost                Decimal              @db.Decimal(10, 0)
  description         String?              @db.Text
  supplier            String?              @db.VarChar(255)
  createdAt           DateTime             @default(now()) @map("created_at")
  updatedAt           DateTime             @updatedAt @map("updated_at")
  procedureMaterials  ProcedureMaterial[]
  priceHistory        PriceHistory[]

  @@index([name])
  @@index([cost])
  @@map("materials")
}

model Procedure {
  id                  Int                  @id @default(autoincrement())
  name                String               @db.VarChar(255)
  categoryId          Int?                 @map("category_id")
  customerPrice       Decimal              @map("customer_price") @db.Decimal(10, 0)
  isRecommended       Boolean              @default(false) @map("is_recommended")
  notes               String?              @db.Text
  createdAt           DateTime             @default(now()) @map("created_at")
  updatedAt           DateTime             @updatedAt @map("updated_at")
  category            Category?            @relation(fields: [categoryId], references: [id])
  procedureMaterials  ProcedureMaterial[]

  @@index([name])
  @@index([categoryId])
  @@index([customerPrice])
  @@index([isRecommended])
  @@map("procedures")
}

model ProcedureMaterial {
  id          Int       @id @default(autoincrement())
  procedureId Int       @map("procedure_id")
  materialId  Int       @map("material_id")
  quantity    Decimal   @default(1.0) @db.Decimal(8, 2)
  createdAt   DateTime  @default(now()) @map("created_at")
  procedure   Procedure @relation(fields: [procedureId], references: [id], onDelete: Cascade)
  material    Material  @relation(fields: [materialId], references: [id], onDelete: Cascade)

  @@unique([procedureId, materialId])
  @@index([procedureId])
  @@index([materialId])
  @@map("procedure_materials")
}

model UploadJob {
  id                String        @id @default(uuid())
  type              String        // 'materials' | 'procedures'
  fileName          String        @map("file_name")
  fileSize          Int?          @map("file_size")
  originalData      Json?         @map("original_data")
  totalRows         Int           @default(0) @map("total_rows")
  processedRows     Int           @default(0) @map("processed_rows") 
  successRows       Int           @default(0) @map("success_rows")
  errorRows         Int           @default(0) @map("error_rows")
  status            String        @default("pending") // 'pending' | 'processing' | 'completed' | 'failed' | 'rollback'
  progressPercentage Decimal      @default(0) @map("progress_percentage") @db.Decimal(5, 2)
  errorDetails      Json?         @map("error_details")
  uploadOptions     Json?         @map("upload_options")
  startedAt         DateTime?     @map("started_at")
  completedAt       DateTime?     @map("completed_at")
  createdBy         String?       @map("created_by")
  createdAt         DateTime      @default(now()) @map("created_at")
  dataBackups       DataBackup[]

  @@index([status])
  @@index([type])
  @@index([createdAt])
  @@map("upload_jobs")
}

model PriceHistory {
  id           Int      @id @default(autoincrement())
  materialId   Int      @map("material_id")
  oldPrice     Decimal  @map("old_price") @db.Decimal(10, 0)
  newPrice     Decimal  @map("new_price") @db.Decimal(10, 0)
  changedBy    String?  @map("changed_by") @db.VarChar(255)
  changeReason String?  @map("change_reason") @db.Text
  changedAt    DateTime @default(now()) @map("changed_at")
  material     Material @relation(fields: [materialId], references: [id])

  @@index([materialId])
  @@index([changedAt])
  @@map("price_history")
}
```

### 6. 초기 데이터 마이그레이션

#### 5.1 Excel 데이터 마이그레이션 스크립트
```typescript
// migration/import-excel-data.ts
import { PrismaClient } from '@prisma/client';
import * as XLSX from 'xlsx';

const prisma = new PrismaClient();

async function importExcelData() {
  try {
    // 1. 재료 데이터 가져오기
    const materialWorkbook = XLSX.readFile('재료_시술_리스트.xlsx');
    const materialSheet = materialWorkbook.Sheets['재료 리스트'];
    const materialData = XLSX.utils.sheet_to_json(materialSheet, { header: 1 });

    // 2. 재료 데이터 삽입
    for (let i = 1; i < materialData.length; i++) {
      const [name, cost] = materialData[i];
      if (name && cost) {
        await prisma.material.create({
          data: {
            name: name.toString(),
            cost: Number(cost)
          }
        });
      }
    }

    // 3. 시술 데이터 가져오기
    const procedureWorkbook = XLSX.readFile('시술_리스트NEW.xlsx');
    const procedureSheet = procedureWorkbook.Sheets['시술 리스트'];
    const procedureData = XLSX.utils.sheet_to_json(procedureSheet, { header: 1 });

    // 4. 시술 데이터 삽입
    for (let i = 1; i < procedureData.length; i++) {
      const [name, categoryName, customerPrice, materials] = procedureData[i];
      
      if (name && customerPrice) {
        // 카테고리 찾기 또는 생성
        let category = await prisma.category.findUnique({
          where: { name: categoryName || '기타' }
        });
        
        if (!category) {
          category = await prisma.category.create({
            data: { name: categoryName || '기타' }
          });
        }

        // 시술 생성
        const procedure = await prisma.procedure.create({
          data: {
            name: name.toString(),
            categoryId: category.id,
            customerPrice: Number(customerPrice)
          }
        });

        // 재료 연결
        if (materials) {
          const material = await prisma.material.findUnique({
            where: { name: materials.toString() }
          });
          
          if (material) {
            await prisma.procedureMaterial.create({
              data: {
                procedureId: procedure.id,
                materialId: material.id,
                quantity: 1.0
              }
            });
          }
        }
      }
    }

    console.log('데이터 마이그레이션 완료');
  } catch (error) {
    console.error('마이그레이션 에러:', error);
  } finally {
    await prisma.$disconnect();
  }
}
```

### 7. 주요 쿼리 예시 (대량 업로드 추가)

#### 6.1 마진 TOP 5 조회
```sql
SELECT name, customer_price, margin, margin_rate 
FROM procedure_summary 
ORDER BY margin DESC 
LIMIT 5;
```

#### 6.2 마진율 TOP 5 조회  
```sql
SELECT name, customer_price, margin, margin_rate 
FROM procedure_summary 
ORDER BY margin_rate DESC 
LIMIT 5;
```

#### 6.3 카테고리별 평균 마진율
```sql
SELECT 
  category_name,
  COUNT(*) as procedure_count,
  ROUND(AVG(margin_rate), 1) as avg_margin_rate,
  SUM(margin) as total_margin
FROM procedure_summary 
GROUP BY category_name 
ORDER BY avg_margin_rate DESC;
```

#### 7.4 업로드 작업 현황 조회
```sql
SELECT 
  id,
  type,
  file_name,
  total_rows,
  processed_rows,
  success_rows,
  error_rows,
  status,
  progress_percentage,
  created_at
FROM upload_jobs 
ORDER BY created_at DESC 
LIMIT 10;
```

#### 7.5 실패한 업로드 상세 조회
```sql
SELECT 
  uj.file_name,
  uj.error_details,
  uj.total_rows,
  uj.error_rows,
  uj.created_at
FROM upload_jobs uj
WHERE uj.status = 'failed'
  AND uj.error_rows > 0
ORDER BY uj.created_at DESC;
```

### 8. 성능 최적화 (업로드 시스템 포함)

#### 7.1 인덱스 전략
- 검색이 자주 발생하는 컬럼에 인덱스 생성
- 복합 인덱스로 다중 조건 검색 최적화
- 외래키 컬럼에는 자동으로 인덱스 생성

#### 7.2 쿼리 최적화
- N+1 문제 해결을 위한 JOIN 사용
- 뷰를 활용한 복잡한 계산 결과 캐싱
- 페이지네이션으로 대량 데이터 처리

#### 8.4 대량 업로드 최적화
- 배치 처리로 메모리 사용량 제어
- 트랜잭션 단위 최적화 (100건씩 배치)
- 백그라운드 작업 큐를 통한 비동기 처리
- 프로그레스 업데이트 빈도 조절

#### 8.5 임시 파일 관리
```sql
-- 오래된 업로드 작업 정리 (30일 이상)
DELETE FROM upload_jobs 
WHERE created_at < NOW() - INTERVAL '30 days'
  AND status IN ('completed', 'failed');

-- 오래된 백업 데이터 정리
DELETE FROM data_backup 
WHERE created_at < NOW() - INTERVAL '7 days';
```

### 9. 보안 고려사항 (업로드 시스템 포함)
- SQL 인젝션 방지 (Prisma ORM 사용)
- 사용자 권한별 접근 제어
- 중요 데이터 암호화
- 정기적인 백업 및 복구 테스트
- **업로드 파일 검증**: 파일 타입, 크기 제한
- **임시 파일 보안**: 업로드 후 자동 삭제
- **데이터 무결성**: 업로드 전 데이터 검증
- **롤백 보안**: 권한 있는 사용자만 롤백 가능

#### 9.1 백업 및 복구 (업로드 고려)
```sql
-- 정기 백업 (업로드 테이블 포함)
pg_dump cost_management_db > backup_$(date +%Y%m%d).sql

-- 선택적 복구 (업로드 작업 제외)
pg_restore --exclude-table=upload_jobs --exclude-table=data_backup backup_file.sql

-- 업로드 작업만 백업
pg_dump -t upload_jobs -t data_backup cost_management_db > upload_backup.sql
```